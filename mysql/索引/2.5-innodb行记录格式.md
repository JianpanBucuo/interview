# 行记录

## 变长列

- 数据长度不固定的数据类型
  Varchar, Varbinary, Blob, Text

- 占用空间大于 768Byte 的不变长类型
  Char

- 变长编码下的 Char
  utf8 下的所占磁盘空间长度不固定

## 行溢出数据

- 由于 InnoDB 每个数据页容量有限，导致数据字段也是有限的

- 当数据字段过大时，InnoDB 会使用行溢出机制
- 行溢出机制会把超长字段放入单独开辟的数据页

`行记录太大，会导致一个页中行记录太少`

会把过长的数据存储到 Blob 页中

## InnoDB 行记录格式 row format

- 行记录格式主要分为两个时代：
  Redundant / Compact （Antelope 文件格式） （老的，现在基本不用）
  `Dynamic` / Compressed （Barracuda 文件格式）

### Redundant

- Mysql 5.0 之前的 Row format

字段偏移列表|HEADER|ROWID|TxID|Roll pointer | Col1 | Col2

`字段偏移列表`用来记录每个字段的相对位置
`| 在物理上是不存在的`
按照列的顺序逆序放置
`HEADER`列数量，字段偏移表的单位，下一行记录的指针等信息

为什么冗余？
字段偏移列表记录了变长字段的长度和定长字段的长度 （信息冗余）

### Compact

紧凑
Mysql5.1 默认的 Row format
`改进了字段偏移列表`
少了 `字段偏移列表` 多了 `变长字段长度表`和 `null标志位`

- 变长字段长度表 记录每个变长字段的长度
- null 标志位 一个 byte
- Col 里有 前 768Byte 的数据 和 Blob 页指针

## Dynamic `使用的最多`

动态 （有的时候是数据 有的时候是指针）

Mysql 5.7 之后的 Row Format

数据长度小于 40Byte 直接放到行里
数据溢出时只记录 blob 页指针

## Compressed

对表的数据航使用 Zlib 算法进行了压缩存储

可以节约 40%左右空间，但对 cpu 的压力较大 -（时间换空间）

## 总结

- 行记录格式进化的核心需求时节约行记录空间
- 节约行记录空间让 B+树所承载的数据数量变多，提高查询效率
