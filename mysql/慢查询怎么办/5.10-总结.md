# 总结

## 慢查询怀疑的方向

1. 索引设计有问题

- 该建索引的没建索引
- 改建联合索引的没建
- 联合索引数据有问题

2. sql 语句有问题

- 加了运算

3. 数据库选错索引 force

## 改进方向

1. 覆盖索引：查询语句从执行到返回结果均使用同一个索引
2. 索引覆盖通过取消回表操作，提升查询效率
3. 可以通过优化 sql 语句或优化联合索引，来使用覆盖索引

## 索引基数

索引区分度估算

1. 使用 force index 可以强制使用索引
2. analyze table 可以重新统计索引信息，修复基数信息

## count 函数

count(非索引字段)： 无法使用索引覆盖，最慢
count(索引字段)： 可以使用覆盖索引，但依然要取出数据判空
count(1): 不需要取出数据，但需要判断 1 是否为 null
count(\*) 经过 mysql 专门优化，遍历一条 B+树，不需要判空，理论最快

## ordery by

1. mysql 排序一般需要生成红箭结果集，排序，回表的过程
2. 索引覆盖是最高效处理排序的方法

## 随机选取

- 临时优化：使用 sql 语句选出随机主键
- 业务优化： 使用业务选出随机偏移量，再用分页查询语法

## 索引下推

-

## 字段函数操作

- mysql 中，对索引字段做函数操作，优化器会放弃索引

- 这种情况可能包括： 时间函数， 字符串转数字，字符编码转换

- 解决方法： 时间函数转区间， 数字强转字符串，高级编码转低级

## 分页查询

- 排序偏移量大时，会丢弃大量无用数据，导致效率低下
- 可以采取先索引覆盖，再用最终 ID 回表的方法，优化效率
